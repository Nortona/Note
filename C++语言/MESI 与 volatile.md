
### MESI优化和引入的问题

缓存的一致性消息传递是需要的时间，这就使其切换时产生延迟。当一个缓存被切换状态时，其他缓存收到消息，完成各自的切换并且发出回应消息，这么一长串的时间中，CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题；



**Store Bufferes**
CPU0 只需要在写入共享数据时，直接把数据写入到 store bufferes中，同时发送invalidate消息，然后继续去处理其他指令（异步） 当收到其他所有 CPU 发送了invalidate acknowledge消息时，再将store bufferes中的数据数据存储至缓存行中，最后再从缓存行同步到主内存。但是这种优化就会带来了可见性问题，也可以认为是CPU的乱序执行引起的或者说是指令重排序(指令重排序不仅仅在CPU层面存在，编译器层面也存在指令重排序)。  
我们通过下面一个简单的示例来看一下指令重排序带来的问题。

处理器会尝试从存储缓存（Store Bufferes）中读取值，但他还没有进行提交。这个的解决方案为Store Forwarding，他使得加载的时候，如果存储缓存中存在，则进行返回。
保存什么时候会完成，无法保证，可能会断电丢失。



指令重排导致的可见性问题可能会导致数据的不一致。CPU就给我们提供了一直通过软件告知CPU什么指令不能重排，什么指令能重排的机制就是**内存屏障**。

CPU知道什么时候需要加入内存屏障，什么时候不需要吗？CPU将这个加入内存屏障的时机交给了程序员。

CPU内存屏障主要分为以下三类：  
**写屏障(Store Memory Barrier)**：告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对写屏障之后的读或者写是可见的。  
**读屏障(Load Memory Barrier)**：处理器在读屏障之后的读操作,都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的。  
**全屏障(Full Memory Barrier)**：确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作。


内存屏障的作用可以通过防止 CPU 对内存的乱序访问来保证共享数据在多线程并行执行下的可见性，但是这个屏障怎么来加呢？回到最开始我们讲 volatile关键字的代码，这个关键字会生成一个 lock 的汇编指令，这个就相当于实现了一种内存屏障。接下来我们进入volatile原理分析的正题


**volatile**关键字的作用和原理。

1.  被**volatile**关键字修饰的共享变量进行写操作的时候会被添加上**LOCK**指令，从而会引发两件事情。
    - 将当前处理器缓存行的数据写回到主存；
    - 由于**缓存一致性协议**，写回主存的操作会使其它处理器对该数据的缓存失效，从而需要重新从主存中加载最新数据。
2.  被**volatile**关键字修饰的共享变量在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

上述第一点是**volatile**提供的**可见性**，上述第二点是**volatile**提供的**有序性**。
