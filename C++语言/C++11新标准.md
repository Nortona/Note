### 自动类型推导

C++11引入了auto关键字，可以让编译器自动推导变量的类型。这样可以减少代码中的重复代码，提高代码的可读性和可维护性。例如：

``` c++
auto i = 42; // 推导为int类型
auto d = 3.14; // 推导为double类型
auto s = "hello"; // 推导为const char*类型
```

### lambda表达式

C++11引入了lambda表达式，可以方便地定义匿名函数。这样可以减少代码中的重复代码，提高代码的可读性和可维护性。例如：

``` c++
auto f = [](int x, int y) { return x + y; };
int z = f(1, 2); // z的值为3
```

#### 右值引用

C++11引入了右值引用，可以方便地实现移动语义和完美转发。这样可以提高代码的性能和效率。例如：

``` c++
class MyString {
public:
    MyString() : data_(nullptr), size_(0) {}
    MyString(const char* str) : data_(new char[strlen(str) + 1]), size_(strlen(str)) {
        strcpy(data_, str);
    }
    MyString(MyString&& other) : data_(other.data_), size_(other.size_) {
        other.data_ = nullptr;
        other.size_ = 0;
    }
    ~MyString() {
        delete[] data_;
    }
private:
    char* data_;
    size_t size_;
};
```


更多关于右值引用的内容，感兴趣的小伙伴可以翻看我之前的帖子，有专门的介绍。

### 智能指针

C++11引入了智能指针，可以方便地管理动态分配的内存，避免内存泄漏和悬空指针的问题。C++11中有两种智能指针：std::unique_ptr和std::shared_ptr。

std::unique_ptr是一种独占式智能指针，它拥有对动态分配的对象的唯一所有权。当std::unique_ptr被销毁时，它所拥有的对象也会被销毁。例如：

``` c++
std::unique_ptr<int> p(new int(42));
std::cout << *p << std::endl; // 输出42

```

std::shared_ptr是一种共享式智能指针，它可以被多个指针共享拥有权。当最后一个std::shared_ptr被销毁时，它所拥有的对象也会被销毁。例如：

```c++
std::shared_ptr<int> p1(new int(42));
std::shared_ptr<int> p2 = p1;
std::cout << *p1 << " " << *p2 << std::endl; // 输出42 42
```

C++11的智能指针使得动态内存管理更加方便和安全。

### range-based for循环

C++11引入了range-based for循环，可以方便地遍历容器中的元素。这样可以减少代码中的重复代码，提高代码的可读性和可维护性。例如：

``` c++
std::vector<int> v = {1, 2, 3, 4, 5};
for (auto x : v) {
    std::cout << x << std::endl;
}

```
### nullptr

C++11引入了nullptr关键字，可以代替NULL宏定义。这样可以避免一些潜在的错误。例如：

``` c++
void f(int* p) {}
f(nullptr); // 可以编译通过
```

### constexpr

C++11引入了constexpr关键字，可以在编译期间计算表达式的值。这样可以提高代码的性能和效率。例如：

``` c++
constexpr int factorial(int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}
int x = factorial(5); // x的值为120
```

更多关于constexpr的内容，感兴趣的小伙伴可以翻看我之前的帖子，有专门的介绍。

### static_assert

C++11引入了static_assert关键字，可以在编译期间检查表达式的值是否为真。这样可以避免一些潜在的错误。例如：

``` c++
static_assert(sizeof(int) == 4, "int must be 4 bytes"); // 如果sizeof(int)不等于4，编译会失败
```

### 变长参数模板

C++11引入了变长参数模板，可以方便地处理可变数量的参数。这样可以提高代码的灵活性和可维护性。例如：

``` c++
template<typename... Args>
void f(Args... args) {
    std::cout << sizeof...(args) << std::endl; // 打印参数的数量
}
f(1, 2, 3); // 打印3
f("hello", 3.14); // 打印2
```

### 线程支持库

C++11引入了线程支持库，可以方便地创建和管理线程。这样可以提高代码的并发性和可维护性。例如：

``` c++
#include <iostream>
#include <thread>
void f() {
    std::cout << "hello, world" << std::endl;
}
int main() {
    std::thread t(f); // 创建一个新线程
    t.join(); // 等待线程结束
    return 0;
}

```






