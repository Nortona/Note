# C++编译过程

`C++`是一种高级编程语言，但是计算机并不能直接理解它。因此，需要将`C++`代码翻译成计算机可以理解的机器语言。这个过程就是编译过程，是`C++`程序从源代码到可执行文件的转换过程，包括**预处理、编译、汇编和链接**四个阶段。

## 1. 预处理

在编译器开始编译之前，会先进行预处理。预处理器会处理代码中的所有预处理指令，例如`#include`和`#define`等。它会将这些指令替换成对应的代码，生成一个新的文本文件。这个新的文本文件就是编译器的输入。在预处理的过程中，还会进行条件编译，即根据条件来选择是否编译某些代码块。预处理完成后，会生成一个没有宏定义和条件编译的中间文件。

预处理器的主要作用是解决代码中的宏定义，它会将宏定义展开成对应的代码。此外，预处理器还会处理`#include`指令，将指定的头文件插入到源文件中，以便让编译器能够对头文件中的函数和变量进行编译。

处理规则见下

1、删除所有的#define，展开所有的宏定义。

2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
`#include 的作用就是仅仅替换`
如在math.cpp中：
```cpp
#include "mul.h"
int main()
{
    int a = 10;
    int b = 4;
    multipy(a, b);
    return 0;
}
```

mul.h 的文件内容为
```cpp
int multipy(int a, int b)
{
	return a * b;
}
```
此时编译不会报错


4、删除所有的注释，“//”和“/**/”。

5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。

6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。



预处理后得到.i文件
```cpp
#line 1 "C:\\Users\\Nortona\\source\\repos\\ConsoleApplication20\\ConsoleApplication20\\ConsoleApplication20.cpp"



#line 1 "C:\\Users\\Nortona\\source\\repos\\ConsoleApplication20\\ConsoleApplication20\\mul.h"
#pragma once
int multipy(int a, int b)
{
	return a * b;
}
#line 5 "C:\\Users\\Nortona\\source\\repos\\ConsoleApplication20\\ConsoleApplication20\\ConsoleApplication20.cpp"
int main()
{
    int a = 10;
    int b = 4;
    multipy(a, b);
    return 0;
}
```

## 2. 编译

编译器将预处理后的.i文件作为输入，对其进行词法分析、语法分析和语义分析等处理。这些处理会将代码转化成中间代码，中间代码是一种类似于汇编语言的低级代码。编译器将代码分成多个模块，每个模块编译成一个对象文件。在编译的过程中，编译器会对代码进行优化，以提高程序的运行效率和节省内存空间。

在词法分析和语法分析的过程中，编译器会对代码进行检查，以确保代码的正确性和合法性。语义分析的任务是在代码的语法结构上进行分析，以确定代码的含义和作用。

```shell
g++ main.cpp -c 

//得到main.o
```





## 3. 汇编

中间代码会被汇编器转化成机器语言指令，这些指令可以被计算机直接执行。汇编的过程将每个对象文件转换成机器语言的目标文件。每个目标文件包含机器指令和数据，以及其他的控制信息。目标文件可以被链接器用于构建可执行文件。

汇编器的主要任务是将中间代码翻译成机器语言指令，以便让计算机能够执行代码。在这个过程中，汇编器会将每个源文件编译成一个目标文件，然后将所有的目标文件组合成一个可执行文件。

## 4. 链接

在编译过程中，可能会用到其他的库文件和对象文件。链接器会将这些文件与生成的可执行文件进行链接，生成最终的可执行文件。链接器的主要任务是解决符号引用问题，即通过在不同的目标文件中查找符号的定义，使得所有的符号都能够正确地被解析和链接。链接器还会对代码进行优化和压缩，以减小可执行文件的体积，并提高程序的运行效率。

链接器的工作包括将每个目标文件中的符号解析成地址，并将它们组合成一个单独的地址空间。链接器还会处理代码中的重定位信息，以确保代码能够正确地加载和执行。

```shell
g++ *.o -o 

//得到main
```

### 动态链接、静态链接
静态链接和动态链接两者**最大的区别就在于链接的时机不一样**，**静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时**，下面来详细介绍这两种链接方式。

#### 静态链接
多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是**每个源文件都是独立编译**的，即每个*.c文件会形成一个*.o文件，为了满足前面说的依赖关系，则**需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序**。这个链接的过程就是静态链接

由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件

根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。

![[Pasted image 20230825154429.png]]

链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。

**静态链接的缺点**很明显
一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；
另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

**静态链接的优点**就是
在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。


#### 动态链接
动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难

动态链接的基本思想**是把程序按照模块拆分成各个相对独立部分**，**在程序运行时才将它们链接在一起形成一个完整的程序**，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：

假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。

动态链接的优缺点
**动态链接的优点**显而易见，就是**即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本**；
另一个优点是，**更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍**。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。


## 结论

`C++`编译过程是一个非常复杂的过程，它需要经过多次处理才能最终生成可执行文件。但是，了解这个过程对于理解`C++`代码和调试程序都非常有帮助。在实际的开发中，程序员需要掌握编译工具链的使用，以便能够更好地进行调试和优化。同时，程序员还需要了解编译器的工作原理和优化技术，以写出高效的`C++`代码。


# 静态库和动态库如何制作及使用，区别是什么
1. 静态库的制作和使用 - 命名规则 Linux : libxxx.a lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib - 制作 a.gcc 获得 .o 文件 gcc xxx.c xxx.c -c b.将 .o 文件打包，使用 ar 工具（archive） ar rcs libxxx.a xxx.o xxx.o - 使用 静态库使用需要有库文件和头文件，编译程序时通过 “-l 静态库名” 参数进行编译。 

2. 动态库的制作 - 命名规则 Linux : libxxx.so lib : 前缀（固定） xxx : 库的名字，自己起 .so : 后缀（固定） Windows : libxxx.dll - 制作 a.gcc 得到 .o 文件，得到和位置无关的代码 gcc -c –fpic/-fPIC a.c b.c b.gcc 得到动态库 gcc -shared a.o b.o -o libcalc.so - 使用 动态库使用需要有库文件和头文件，编译程序时通过 “-l 动态库名” 参数进行编译。在运行程序之前还需要配置动态库的加载路径，程序才能够正常运行。

3. 静态库和动态的区别 
	- 静态库 gcc 进行链接时，会把静态库中代码打包到可执行程序中，编译时加载；发1布程序时无需提供静态库，移植方便；消耗内存，更新部署发布麻烦。 
- 动态库 gcc 进行链接时，动态库的代码不会被打包到可执行程序中，运行时加载；发布程序时需要提供动态库；内存占用小，更新部署发布简单。

# 请你说说动态库静态库的区别和优缺点
1. 命令方式不同 
- 静态库命名 Linux : libxxx.a         lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib 
- 动态库命名 Linux : libxxx.so       lib : 前缀（固定） xxx : 库的名字，自己起 .so : 后缀（固定） Windows : libxxx.dll 

2. 链接时间和方式不同 
- 静态库的链接是将整个函数库的所有数据在编译时都整合进了目标代码 
- 动态库的链接是程序执行到哪个函数链接哪个函数的库 

静态库和动态库的优缺点： 
1. 静态库优缺点 
- 优点：发布程序时无需提供静态库，移植方便，运行速度相对快些
- 缺点：静态链接生成的可执行文件体积较大，消耗内存，如果所使用的静态库发生更新改变，程序必须重新编译，更新麻烦。 

2. 动态库优缺点
- 优点：更加节省内存并减少页面交换，动态库改变并不影响使用的程序，动态函数库升级比较方便 
- 缺点：发布程序时需要提供动态库


开发SDK
https://zhuanlan.zhihu.com/p/163754857