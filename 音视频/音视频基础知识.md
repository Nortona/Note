# 比特率
显示一段视频每秒所需的比特数量就是它的**比特率**。
> 比特率 = 宽 * 高 * 比特深度 * 帧每秒

例如，一段每秒30帧，每像素24比特，分辨率是480x240的视频，如果我们不做任何压缩，它将需要 **82,944,000 比特每秒**或 82.944 Mbps (30x480x240x24)。



# 视频压缩

使用一个视频而不做任何压缩是不可行的；**一个单独的一小时长的视频**，分辨率为720p和30fps时将**需要 278GB***。由于**仅使用独自无损数据压缩算法**，如 DEFLATE（被PKZIP, Gzip, 和 PNG 使用），**不会**足够减少所需的带宽，我们需要找到其它压缩视频的方法。
 >我们使用乘积得出这个数字 1280 x 720 x 24 x 30 x 3600 （宽，高，每像素比特数，fps 和秒数）

## 三角帧技术

==帧类型：I P B==
这是最开始的 4 帧。
![[Pasted image 20230504224739.png]]

以在帧内看到**很多重复内容**，如**蓝色背景**，从 0 帧到第 3 帧它都没有变化。为了解决这个问题，我们可以将它们**抽象地分类**为三种类型的帧。
#### **I 帧（帧内编码，关键帧）**

I 帧（可参考，关键帧，帧内编码）是一个**自足的帧**。它不依靠任何东西来渲染，I 帧与静态图片相似。第一帧通常是 I 帧，但我们将看到 I 帧被定期插入其它类型的帧之间。

#### **P 帧（预测）**
![[Pasted image 20230504224942.png]]

P 帧利用了一个事实：当前的画面几乎总能**使用之前的一帧进行渲染**。例如，在第二帧，唯一的改变是球向前移动了。仅仅使用（第二帧）对前一帧的引用和差值，我们就能重建前一帧。

#### **B 帧（双向预测）**

如何引用前面和后面的帧去做更好的压缩？！简单地说 B 帧就是这么做的。
![[Pasted image 20230504225129.png]]


 I 帧是昂贵的，P 帧是便宜的，最便宜的是 B 帧。
 ![[Pasted image 20230504225059.png]]



## 时间冗余（帧间预测）
包括==运动估计==和==运动补偿==

1. 简单地**从帧 0 里减去帧 1**，就可以得到刚好需要我们**去编码的剩余值**。
![[Pasted image 20230505131900.png]]
![[Pasted image 20230505131904.png]]

2. 块运动补偿
**块运动补偿**是将当前帧划分为非重叠的块，并且运动补偿向量**告诉这些块来自哪里**
![[Pasted image 20230505132052.png]]

预计那个球会从 `x=0, y=25` 移动到 `x=6, y=26`，**x** 和 **y** 的值就是**运动向量**。我们**下一步**可以通过只对在最终块的位置和预期值之间的**运动向量差进行编码**来节省比特，那么最终运动向量就是 `x=6 (6-0), y=1 (26-25)`。

运用**运动预测**时**编码的数据少于**使用简单的三角帧技术。（ 三角帧：在视频压缩技术里，P 帧或 B 帧的别名。）



## 空间冗余（帧内预测）
如果我们分析一个视频里的**每一帧**，我们会看到有**许多区域是相互关联的**。
![[Pasted image 20230505134351.png]]

这是一个 `I 帧`，并且我们**不能使用前面的帧来预测**，但仍然可以压缩它。我们将编码选择的红色块。如果我们**看看它的周围**，我们可以**估计它周围颜色的趋势**。
![[Pasted image 20230505134506.png]]

**预计**帧将继续**垂直传播（它的）颜色**，这意味着**未知像素的颜色将保持其邻居的值**。
![[Pasted image 20230505135028.png]]


我们的**预计也会错**，所以我们需要应用这项技术（**帧间预测**），然后**减去给我们的残差块的值**，得出一个相比原始数据可压缩的矩阵。
![[Pasted image 20230505134458.png]]


ffmpeg查看运动预测
```shell
ffmpeg -flags2 +export_mvs -i mv.mp4 -vf codecview=mv=pf+bf+bb mv_vis_mv.mp4
```