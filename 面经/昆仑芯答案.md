
解码后的格式不一定是我们播放器想要的？
PCM格式不是SDL支持的 S16 44100
YUV -> RGB

这三种是最基本的策略，**考虑到人对声音的敏感度要强于视频，频繁调节音频会带来较差的观感体验，且音频的播放时钟为线性增长，所以一般会以音频时钟为参考时钟，视频同步到音频上。**
![[Pasted image 20230902030213.png]]

![[41d24a04723719c60b45fe5c2fb284a.jpg]]


# seek 
seek成功时清空list， seektime置0
```cpp
qDebug() << "seek成功" << _seekTime << ts << streamIdx;
_vSeekTime = _seekTime;
_aSeekTime = _seekTime;
_seekTime = -1;
// 恢复时钟
_aTime = 0;
_vTime = 0;
// 清空之前读取的数据包
clearAudioPktList();
clearVideoPktList();
```

1、面试官的问题：播放器的解码线程如果有一个流出问题了，解封装线程访问不到该锁，怎么不影响其他的流？ 

优化建议：你的项目中已经将解封装、音频解码、视频解码拆成了不同的线程，这是 OK 的。这里可以优化的思路是解封装、音视频解码、渲染的流程是一个 pipeline，这里是典型的生产消费者模型，所以可以在每一对生产者/消费者角色之间设置一个缓冲区，通过控制缓冲区的长度来约束生产者的动作，对缓冲区的互斥操作加上锁即可。在这个基础上，解码线程的一个流出问题就不太会影响解封装线程，解码线程总是从音频或视频的 packet 缓冲区取数据，解封装线程总是从 I/O 拿数据解封装后放到音频或视频的 packet 缓冲区，只要做好缓冲区的互斥访问即可。 2、面试官的问题：如果视频慢了怎么办，直接丢视频帧不会画面波动吗？ 优化建议：这个是面试官对你项目中设计不合理地方的疑问。比较好的实现方式还是上面讲的通过生产消费者模型及二者之间的缓冲区来控制数据，音视频同步则一般以音频时间作为主时钟，视频去同步音频。具体算法可以参考 ffplay、ijkplayer、VLC、EXOPlayer 等开源项目的实现。 3、面试官的问题：为什么要对音频重采样，对视频格式转换，怎么就提高播放器对音视频文件的兼容性？ 优化建议：播放器对音频重采样、对视频格式转换一般是对接渲染模块的需要，通常应该尽量实现渲染模块支持的音视频格式与解码输出的格式互相兼容。视频上屏一般需要 RGB 类的格式，解码一般出来的是 YUV 类的格式，通常是要有一次转换，其他情况应该尽量减少转换。 4、面试官的问题：暂停时对与 buffer 是否有保护？ 优化建议：这里面试官想问的应该是播放暂停了，解码、解封装是否还一直在进行，这样的话它们的 buffer 是否会被撑爆或者丢失旧数据。这里一般通过设置 buffer 的上限来控制解封装、解码在合适的时候暂停。