# 计网
## TCP为什么有三次握手？
[[面经答案#8. TCP 三次握手、四次挥手]]

## HTTP状态码，常用状态码

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：

常见的 HTTP 状态码：

-   200 - 请求成功
-   301 - 资源（网页等）被永久转移到其它URL
-   404 - 请求的资源（网页等）不存在
-   500 - 内部服务器错误

## OSI七层网络模型，每一层对应协议
   
-   应用层：各种应用软件，包括 Web 应用。   

-   表示层：数据格式标识，基本压缩加密功能。

-   会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。

-   传输层：端到端传输数据的基本功能；如 TCP、UDP。

-   网络层：定义IP编址，定义路由功能；如不同设备的数据转发。

-   数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。

-   物理层：底层数据传输，如网线；网卡标准。

![[Pasted image 20230513005218.png]] ![[Pasted image 20230513005412.png]]


## ping的工作原理
ping主要是用来探测主机和主机之间是否可以进行通信，如果不能ping到某台主机，表示不能与这台主机建立连接。ping使用的是==ICMP协议==，他发送ICMP回送请求消息给目的主机。ICMP协议规定：==目的主机必须返回ICMP回送应答消息给源主机，如果源主机在一定时间内收到应答，表明主机可达==。ICMP协议是通过==IP协议==发送的，IP协议是无连接的，不可靠的数据报协议。

## TCP三次握手相关，三次握手与网络编程API的对应关系
在socket编程中
服务端：socket() -> bind()-> listen()-> accept() -> recv() / send()-> close()
客户端：socket() -> connect() -> send() / recv() -> close()

客户端执行connect()时，将触发三次握手。

[[面经答案#8. TCP 三次握手、四次挥手]]
![[Pasted image 20230513011644.png]]



## 实现客户端TCP通信需要用到的socket API

socket() -> connect() -> send() / recv() -> close()

##  GET 和 POST的概念和区别
1.  get是获取数据，post是修改数据
2.  get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）
3.  get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。
4. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
5. 本质区别：GET是幂等的，而POST不是幂等的

`幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。`

**不能用get请求做数据的增删改这些有副作用的操作**。因为get请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用get请求增数据，会有**重复操作**的风险

## HTTP请求报文和响应报文结构
### 请求报文

-   请求行：Request Line
-   请求头：Request Headers
-   请求体：Request Body

### 响应报文

-   状态行：Status Line
-   响应头：Response Headers
-   响应体：Response Body

## TCP与UDP的区别

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

7、UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小

TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小

## 网络编程API的具体功能
### 服务端
socket()

bind()

listen()

accept()

recv()

send()

close()

### 客户端
socket()

connect()

send()

recv()

close()

## TCP 粘包

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

### 原因

1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.

2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)

3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

### 解决方案

1、消息定长。

2、在包尾部增加回车或者空格符等特殊字符进行分割

3、将消息分为消息头和消息尾

4、使用其它复杂的协议，如RTMP协议等

## TCP的特性和保证特性的原理
### 特性
有连接传输

面相字节流

提供可靠传输

全双工

有接收缓冲区和发送缓冲器

### 保证特性的原理
三次握手，四次挥手，差错检验，拥塞控制，流量控制，延迟应答（接收多个包后再发送ACK）


## A、B、C三种网络的区分
一个A类IP地址是指，在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1个字节的网络地址和3个字节的主机地址组成，网络地址的最高位必须是0
A类IP地址中==网络的标识长度是8位==，主机标识的长度是24位，==A类网络地址较少，只有126个网络==，每个网络可以容纳`255*255*255-2 = 16581373`台主机。

A类地址网络号范围:`1.0.0.0 ~ 126.0.0.0`

一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2个字节主机地址组成，网络地址的最高位必须是`10`。
B类IP地址中网络的标识长度为16位，主机标识长度为16位。B类网络地址适用于中等规模的网络，有`2^14 = 16384`个网络，每个网络可以容纳`256*256-2 = 65534`台计算机
B类IP地址范围`128.0.0.0 ~ 192.255.255.255`，B类IP地址的子网掩码为`255.255.0.0`

`因为10000000.0000000.00000000.00000000是网络地址，10111111.11111111.11111111.11111111是广播地址`

一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机号码 。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是`110`。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数据较多，有`32*256*256=2097152`个网络。适用于小规模的局域网络，每个网络最多只能包含`256-2 = 254`台计算机。C类IP地址范围`192.0.0.0 ~ 223.255.255.255`(二进制：`11000000.00000000.00000000.00000000 ~ 11011111.111111111.11111111.11111111`)  
C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为`256-2=154`台

## IP头部校验具体校验的是什么
使用CRC检验**IP头部**是否损坏

## 网络路由协议
### 静态路由协议
静态路由是手动添加完成的。

### 动态路由协议
动态路由，提前设置好路由协议，路由器之间会定期交换路由信息，路由器会知道网络中其它网段的信息，动态生成路由表。如果网络出现变化，网段需要增删改时，只需要在相应的路由器上配置动态路由即可。

按照路由的算法和路由信息的交换方式，
路由协议可以分为距离矢量（ Distance-Vector ，D-V ）路由协议和链路状态（ Link-State ）路由协议。
其中典型的距离矢量协议是 RIP ，典型的链路状态协议是 OSPF

## 对称加密和非对称加密的区别

对称密码体制使用相同的密钥( 秘密密钥) 对消息进行加密/解密，系统的保密性主要由密钥的安全性决定，而与算法是否保密无关。
常用的对称加密算法有 DES、3DES、AES、TDEA、Blowfish、RC2、RC4 和 RC5 等。


非对称密码体制使用公钥加密消息，使用私钥来解密。使用非对称密码体制可增强通信的安全性。

分别为公钥（Public Key）和私钥（Private Key），其中一把密钥用于加密，另一把密钥用于解密。非对称加密的特征是算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。

常用的非对称加密算发有 RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。

## UDP协议的最大长度，超过最大长度会怎么样

以太网MTU（Maximum Transmission Unit）为1500；  
  
在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；  
  
在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；  
  
所以，在应用层，你的Data最大长度为1472。

### IP协议分片算法

意义：在IP协议中的分片算法主要解决不同物理网络最大传输单元(MTU) 的不同造成的传输问题。

分片：IP分片是网络上传输IP报文的一种技术手段。IP协议在传输数据包时，若数据包大小超过MTU，数据报文将被分为若干分片进行传输，并在目标系统中进行重组。这一过程称为分片（fragmentation）。IP报文的header有数据包的ID和分片标识符。


TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。

## HTTP与HTTPS的异同

1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

## TCP滑动窗口的作用

如果每次传输数据都只能发送一个MSS，就需要等待接收方的ACK，这显然会极大的影响传输的速率。在发送数据的时候，最好的方式是一下将所有的数据全部发送出去，然后一起确认
![[Pasted image 20230421192531.png]]
TCP的包可以分为四种状态
-   发送和已确认的字节（蓝色部分）
-   已发送但尚未确认的字节（黄色部分）
-   未发送的字节和接收方准备接收的字节，即在缓冲区buffer中（绿色部分）
-   未发送且接收方未准备接收的字节，即已经在缓冲区，但是该部分数据还未被处理（灰色部分）

第②和第③部分加起来就刚好是接收方缓冲区大小，发送窗口的最左边缘由接收方的最后一个 _ACK_ 确认决定，而长度由接收方通告的窗口大小决定，它规定了当前发送方能发送的最大数据量。


## CS模型

C/S结构，即Client/Server(客户机/服务器)结构，是大家熟知的软件系统体系结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端硬件环境的优势。早期的软件系统多以此作为首选设计标准。

B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，

## 浏览器输入URL至显示网页的全过程
1、查浏览器缓存，看看有没有已经缓存好的，如果没有

2 、检查本机host文件，

3、调用API，Linux下Socket函数 gethostbyname

4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议

5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）

6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，

7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，

8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，

9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，

10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。

11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页

## 显示浏览器缓存时，还需要联网吗？还需要与服务器端进行通信吗？

浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。缓存会根据进来的请求保存输入内容的副本。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。

对于浏览器的缓存来讲，这些规则是在HTTP协议头部和HTML页面的Meta标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。

过期机制：指的是缓存副本的有效期。一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的：  
1.含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内  
2.浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变)  
满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染

校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag(Entity Tag),它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容。

## TCP连接中，服务端网线拔掉会怎么样

### 有数据传输
在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发**超时重传**机制，重传未得到响应的数据报文。

**如果在服务端重传报文的过程中，客户端刚好把网线插回去了**，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。

此时，客户端和服务端的 TCP 连接依然存在的，就感觉什么事情都没有发生。

但是，**如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去**，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。

而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。

此时，客户端和服务端的 TCP 连接都已经断开了。

### 无数据传输
针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。

如果**没有开启** TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。

而如果**开启**了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：

-   如果**对端是正常工作**的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 **TCP 保活时间会被重置**，等待下一个 TCP 保活时间的到来。
-   如果**对端主机崩溃，或对端由于其他原因导致报文不可达**。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，**TCP 会报告该 TCP 连接已经死亡**。

所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。

## SYN FLood 攻击
**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

## **两个进程，socket的返回值相同，但确实不同的socket通道，为什么**

## TCPdump抓包

tcpdump工作在设备层，在包被送到IP层之前就被抓到，以虚拟协议方法工作

### 不指定任何参数

监听第一块网卡上经过的数据包。主机上可能有不止一块网卡，所以经常需要指定网卡。

```powershell
tcpdump
```

### 监听特定网卡

```powershell
tcpdump -i en0
```

### 监听特定主机

例子：监听本机跟主机`182.254.38.55`之间往来的通信包。

备注：出、入的包都会被监听。

```bash
tcpdump host 182.254.38.55
```

### 特定来源、目标地址的通信

特定来源

```bash
tcpdump src host hostname
```

特定目标地址

```bash
tcpdump dst host hostname
```

如果不指定`src`跟`dst`，那么来源 或者目标 是hostname的通信都会被监听

```bash
tcpdump host hostname
```

### 特定端口

```bash
tcpdump port 3000
```

### 监听TCP/UDP

服务器上不同服务分别用了TCP、UDP作为传输层，假如只想监听TCP的数据包

```bash
tcpdump tcp
```

### 来源主机+端口+TCP

监听来自主机`123.207.116.169`在端口`22`上的TCP数据包

```bash
tcpdump tcp port 22 and src host 123.207.116.169
```

### 监听特定主机之间的通信

```powershell
tcpdump ip host 210.27.48.1 and 210.27.48.2
```

`210.27.48.1`除了和`210.27.48.2`之外的主机之间的通信

```armasm
tcpdump ip host 210.27.48.1 and ! 210.27.48.2
```


##  UDP大量传输时应该注意什么
UDP协议本身不提供大数据传输的分片、重组、丢包重传等功能，因此需要针对大数据传输进行特殊处理。

（1）对大文件进行分块：将大文件划分为多个小块进行传输，每个小块都可以使用UDP协议传输。在接收端，按照顺序组合这些小块，恢复原始文件。

（2）实现数据包重传机制：在UDP协议之上增加数据包重传机制，确保丢失的数据包能够被重新发送并得到正确接收。

（3）设置数据包大小和传输间隔时间：合理设置数据包大小和传输间隔时间，避免过大的数据包或过短的传输间隔带来的负面影响。

（4）实现校验机制：在数据包头部增加校验码，以检测并纠正可能的数据损坏或篡改。

需要注意的是，UDP协议本身并不适合大数据传输，如果数据量过大或要求可靠性较高，建议使用TCP协议或其他专门的数据传输协议。

## 怎么应对ddos攻击？

常见的防御 SYN 攻击的方法有如下几种：
-   缩短超时（SYN Timeout）时间
-   增加最大半连接数
-   过滤网关防护
-   SYN cookies技术

## 访问牛客网的时候，你的本机会跟CA机构数据交互吗

会



# 操作系统
## 进程和线程的区别

进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序。我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执⾏⽂件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，就被称为==「进程」（Process）。==

线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。

线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:

1、根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。
2、地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。
3、上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。



协程是用户态的轻量级线程，线程内部调度的基本单位
|          | 进程                                                                          | 线程                                               | 协程                                                                                 |
| -------- | ----------------------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------------------------ |
| 定义     | 资源分配和拥有的基本单位                                                      | 程序执行的基本单位                                 | 用户态的轻量级线程，线程内部调度的基本单位                                           |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置  | 保存和设置程序计数器、少量寄存器和栈的内容         | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复                                 |
| 切换者   | 操作系统                                                                      | 操作系统                                           | 用户                                                                                 |
| 切换过程 | 用户态->内核态->用户态                                                        | 用户态->内核态->用户态                             | 用户态                                                                               |
| 调用栈   | 内核栈                                                                        | 内核栈                                             | 用户栈                                                                               |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄等                                           | 程序计数器、寄存器、栈和状态字                     | 拥有自己的寄存器上下文和栈                                                           |
| 并发性   | 不同进程之间切换实现并发，各自占有CPU实现并行                                 | 一个进程内部的多个线程并发执行                     | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理             |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |
| 通信     | 进程间通信需要借助操作系统                                                    | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列                                                                   |


## 协程的相关概念 ，协程与线程的异同？

**协程是一种用户态的轻量级线程，协程的调度完全由用户控制**。

一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。

与其让操作系统调度，不如我自己来，这就是协程


1、 一个线程可以多个协程，一个进程也可以单独拥有多个协程。
2、线程进程都是同步机制，而协程则是异步。

3、协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。
6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。

## 读写锁的设计和应用场景


```cpp
#include <stdio.h>
#include <pthread.h>

int num = 0;
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *reader(void* arg){
   
        int times = 100000000;
        while(times--){
   
                pthread_rwlock_rdlock(&rwlock);
                //pthread_mutex_lock(&mutex);
                if(times%1000 == 0)
                        usleep(10);
                pthread_rwlock_unlock(&rwlock);
                //pthread_mutex_unlock(&mutex);
        }
}

void *writer(void* arg){
   
        int times = 100000000;
        while(times--){
   
                pthread_rwlock_wrlock(&rwlock);
                //pthread_mutex_lock(&mutex);
                num += 1;
                pthread_rwlock_unlock(&rwlock);
                //pthread_mutex_unlock(&mutex);
        }
}

int main(){
   
        pthread_t writer_1, reader_1, reader_2;
        pthread_create(&writer_1, NULL, &writer, NULL);
        pthread_create(&reader_1, NULL, &reader, NULL);
        pthread_create(&reader_2, NULL, &reader, NULL);
        pthread_join(writer_1, NULL);
        pthread_join(reader_1, NULL);
        pthread_join(reader_2, NULL);
        printf("num = %d\n", num);
}

```
## 线程同步的概念及方法
1、互斥锁mutex + 条件变量cond_var
2、信号量

## IO多路复用的概念
select、poll、epoll简单介绍一下这几个关键字：select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

## 多进程的通信方式？通信方式的优劣？
-   管道：
    -   ==无名管道==（内存文件）：管道是一种半双工的通信方式，数据==只能单向流动==，而且==只能在具有亲缘关系的进程之间使用==。进程的亲缘关系通常是指父子进程关系。
    -   有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先 出的通信方式。

-   共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。
    
-   消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    
-   套接字(socket)：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。
    
-   信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。
    
-   信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

### 几种方式的优缺点

管道：==速度慢，容量有限==，无名只有父子进程能通讯

FIFO：任何进程间都能通讯，但==速度慢==

消息队列：==容量受到系统限制==，且要注意第一次读的时候，要考虑上一次没有读完数据的问题

信号量：==不能传递复杂消息，只能用来同步==

共享内存区：能够很容易控制容量，速度快，但==要保持同步==，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

## 锁机制是如何实现的？

1、read lock；  
2、判断lock状态；  
3、如果已经加锁，失败返回；  
4、把锁状态设置为上锁；  
5、返回成功。

## ## 信号量机制实现进程互斥？
(1) 确定临界区（如对临界资源打印机的访问就应放在临界区）  
(2) 设置互斥信号量（mutex）。  
(3) **在临界区之前执行P(mutex)**  
(4) **在临界区之后执行V(mutex)**
![[18464438-a926d29280048bf4.webp]]

## 信号量机制实现进程同步
(1) 分析需要同步的两个操作，即必须保证一前一后的执行顺序的操作。  
(2) 设置同步信号量S，初始为0。  
(3) **在前操作之后执行V(S)。**  
(4) **在后操作之前执行P(S)。**

## 僵尸进程的概念 ？

**僵死进程与孤儿进程的区别？**

回答这个问题很简单，就是爸爸（父进程）和儿子（子进程）谁先死的问题！

如果当儿子还在世的时候，爸爸去世了，那么儿子就成孤儿了，这个时候儿子就会被init收养，换句话说，init进程充当了儿子的爸爸，所以等到儿子去世的时候，就由init进程来为其收尸。

如果当爸爸还活着的时候，儿子死了，这个时候如果爸爸不给儿子收尸，那么儿子就会变成僵尸进程。

**避免僵死进程的方法**

网上搜了下，总结有三种方方法：

1、 程序中显示的调用signal（SIGCHLD， SIG＿IGN）来忽略SIGCHLD信号，这样子进程结束后，由内核来wai和释放资源

2、fork两次，第一次fork的子进程在fork完成后直接退出，这样第二次fork得到的子进程就没有爸爸了，它会自动被老祖宗init收养，init会负责释放它的资源，这样就不会有“僵尸”产生了

3、对子进程进行wait，释放它们的资源，但是父进程一般没工夫在那里守着，等着子进程的退出，所以，一般使用信号的方式来处理，在收到SIGCHLD信号的时候，在信号处理函数中调用wait操作来释放他们的资源。


## 进程调度
### 1、`CFS`完全公平调度：
CFS的出发点基于一个简单的理念：即所有进程实际占用处理器CPU的时间应为一致，目的是确保每个进程公平的处理器使用比，即最大的利用了计算资源。
### 2、`FIFO`先入先出队列：
不基于时间片调度，处于可运行状态的SCHED_FIFO级别的进程比SCHED_NORMAL有更高优先级得到调度，一旦SCHED_FIFO级别的进程处于可执行的状态，它就会一致运行，直到进程阻塞或者主动释放。
### 3、`RR`(Round-Robin)：
SCHED_RR级别的进程在耗尽事先分配的时间片之后就不会继续执行。即可以理解将RR调度理解为带有时间片的SCHED_FIFO。

## epoll 及其触发模式

==**红黑树，就绪链表**==
epoll使用一组函数来完成操作，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核上的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集合事件表。但epoll需要使用一个额外的文件描述符，来唯一标识内核中这个事件表，这个文件描述符使用如下epoll_create函数创建

 epoll解决select的1，2，3，4不需要轮询，时间复杂度为O(1)epoll_create 创建一个白板 存放fd_eventsepoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符 
 
epoll的两种触发模式分别是ET(edge trigger)边缘触发和LT(level triggered)水平触发。  
epoll的默认触发模式是LT，select、poll只支持LT触发。

### LT

缓冲区只要有数据未读就会导致epoll_wait返回。  
上次读数据未读完仍会导致epoll_wait返回。  
水平触发模式下阻塞和非阻塞并没有什么区别，因为没有可读时间就绪的话epoll_wait不会返回。

### ET（状态改变触发）

缓冲区出现新未读数据才会导致epoll_wait返回。  
上次读数据未读完不会导致epoll_wait返回。

## 什么是虚拟内存

直接使用物理内存时，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「**虚拟地址**」

每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。

**操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。**

-   我们程序所使用的内存地址叫做**虚拟内存地址**（_Virtual Memory Address_）
-   实际存在硬件里面的空间地址叫**物理内存地址**（_Physical Memory Address_）。
- 
主要有两种方式，分别是**内存分段和内存分页**

## 设计并发系统，怎么选择多线程和多进程，怎么考虑
1.  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，`系统开销比较大`，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，`切换速度也比进程快`，效率高，但是正由于`进程之间独立`的特点，使得`进程安全性比较高`，也因为进程有独立的地址空间，`一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉`。
2.  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。

### 进程与线程的选择取决以下几点：

1.  **需要频繁创建销毁情况：**优先使用线程;因为对进程来说创建和销毁一个进程代价是很大的。
2.  **大量计算，频繁切换：**线程的`切换速度快`，所以在需要`大量计算`，`切换频繁`时用线程，还有`耗时`的操作使用线程可提高应用程序的响应
3.  **并行**：并行操作时使用线程，如C/S 的服务器端并发线程响应用户的请求;
4.  **多机和多核**：因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程;
5.  **安全性**：需要更稳定安全时，适合选择进程（例如：`守护进程模式`）;需要速度时，选择线程更好。

## 多线程开发需要注意什么

线程之间共用进程所有资源，当多线程操作同一个变量的时候，可能会使得结果不正确。

因此要特别注意线程安全的问题。

## 怎么实现一个守护进程

-   父进程fork出子进程并exit退出
-   子进程调用setsid创建新会话
-   子进程调用系统函数chdir将根目录"/"成为子进程的工作目录
-   子进程调用系统函数umask将该进程的umask设置为0
-   子进程关闭从父进程继承的所有不需要的文件描述符
